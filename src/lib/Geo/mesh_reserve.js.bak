// mesh_reserve.js - Track mesh generation for ADOFAI tiles
// This is a placeholder implementation - you'll need to replace this with the actual mesh_reserve.js

export default function createTrackMesh(prevDirection, currentDirection, isMidspin = false) {
  // Calculate the track mesh based on previous and current directions
  const vertices = []
  const faces = []
  const colors = []

  // Basic track dimensions
  const trackWidth = 1.0
  const trackHeight = 0.65
  const trackDepth = 0.2

  if (isMidspin) {
    // Create circular mesh for midspin tiles
    const radius = 0.5
    const segments = 16
    const centerX = 0
    const centerY = 0
    const centerZ = 0

    // Create vertices for circular track
    for (let i = 0; i <= segments; i++) {
      const angle = (i / segments) * Math.PI * 2
      const x = centerX + Math.cos(angle) * radius
      const y = centerY + Math.sin(angle) * radius

      // Top vertices
      vertices.push(x, y, centerZ + trackDepth / 2)
      colors.push(1.0, 0.5, 0.0) // Orange for midspin

      // Bottom vertices
      vertices.push(x, y, centerZ - trackDepth / 2)
      colors.push(1.0, 0.5, 0.0)
    }

    // Create faces for circular track
    for (let i = 0; i < segments; i++) {
      const topCurrent = i * 2
      const bottomCurrent = i * 2 + 1
      const topNext = ((i + 1) % segments) * 2
      const bottomNext = ((i + 1) % segments) * 2 + 1

      // Side faces
      faces.push(topCurrent, bottomCurrent, topNext)
      faces.push(bottomCurrent, bottomNext, topNext)
    }
  } else {
    // Create curved track mesh based on direction change
    const angleDiff = currentDirection - prevDirection
    const isSharpTurn = Math.abs(angleDiff) > 45

    if (isSharpTurn) {
      // Create curved track for sharp turns
      const segments = 8
      const startAngle = (prevDirection * Math.PI) / 180
      const endAngle = (currentDirection * Math.PI) / 180
      const radius = 0.8

      for (let i = 0; i <= segments; i++) {
        const t = i / segments
        const angle = startAngle + (endAngle - startAngle) * t

        // Inner edge
        const innerX = Math.cos(angle) * (radius - trackWidth / 2)
        const innerY = Math.sin(angle) * (radius - trackWidth / 2)

        // Outer edge
        const outerX = Math.cos(angle) * (radius + trackWidth / 2)
        const outerY = Math.sin(angle) * (radius + trackWidth / 2)

        // Top vertices
        vertices.push(innerX, innerY, trackDepth / 2)
        vertices.push(outerX, outerY, trackDepth / 2)
        colors.push(0.8, 0.7, 0.5) // Track color
        colors.push(0.8, 0.7, 0.5)

        // Bottom vertices
        vertices.push(innerX, innerY, -trackDepth / 2)
        vertices.push(outerX, outerY, -trackDepth / 2)
        colors.push(0.7, 0.6, 0.4)
        colors.push(0.7, 0.6, 0.4)
      }

      // Create faces for curved track
      for (let i = 0; i < segments; i++) {
        const base = i * 4
        const nextBase = (i + 1) * 4

        // Top face
        faces.push(base, base + 1, nextBase)
        faces.push(base + 1, nextBase + 1, nextBase)

        // Bottom face
        faces.push(base + 2, nextBase + 2, base + 3)
        faces.push(base + 3, nextBase + 2, nextBase + 3)

        // Inner side
        faces.push(base, nextBase, base + 2)
        faces.push(nextBase, nextBase + 2, base + 2)

        // Outer side
        faces.push(base + 1, base + 3, nextBase + 1)
        faces.push(nextBase + 1, base + 3, nextBase + 3)
      }
    } else {
      // Create straight track for gentle turns
      const halfWidth = trackWidth / 2
      const halfHeight = trackHeight / 2
      const halfDepth = trackDepth / 2

      // Define vertices for a rectangular track segment
      const trackVertices = [
        // Top face
        [-halfWidth, -halfHeight, halfDepth],
        [halfWidth, -halfHeight, halfDepth],
        [halfWidth, halfHeight, halfDepth],
        [-halfWidth, halfHeight, halfDepth],
        // Bottom face
        [-halfWidth, -halfHeight, -halfDepth],
        [halfWidth, -halfHeight, -halfDepth],
        [halfWidth, halfHeight, -halfDepth],
        [-halfWidth, halfHeight, -halfDepth],
      ]

      trackVertices.forEach(([x, y, z]) => {
        vertices.push(x, y, z)
        colors.push(0.8, 0.7, 0.5) // Track color
      })

      // Define faces for the rectangular track
      const trackFaces = [
        // Top face
        [0, 1, 2],
        [0, 2, 3],
        // Bottom face
        [4, 6, 5],
        [4, 7, 6],
        // Front face
        [0, 4, 5],
        [0, 5, 1],
        // Back face
        [2, 6, 7],
        [2, 7, 3],
        // Left face
        [0, 3, 7],
        [0, 7, 4],
        // Right face
        [1, 5, 6],
        [1, 6, 2],
      ]

      trackFaces.forEach(([a, b, c]) => {
        faces.push(a, b, c)
      })
    }
  }

  return {
    vertices: new Float32Array(vertices),
    faces: new Uint16Array(faces),
    colors: new Float32Array(colors),
  }
}
